<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Yusuf.im</title><link href="http://www.yusuf.im/" rel="alternate"></link><link href="http://www.yusuf.im/feeds/devops.atom.xml" rel="self"></link><id>http://www.yusuf.im/</id><updated>2015-04-20T01:43:00+01:00</updated><entry><title>Process monitoring with supervisor</title><link href="http://www.yusuf.im/posts/2015/Apr/20/process%20monitoring%20with%20supervisor/" rel="alternate"></link><updated>2015-04-20T01:43:00+01:00</updated><author><name>Yusuf</name></author><id>tag:www.yusuf.im,2015-04-20:posts/2015/Apr/20/process monitoring with supervisor/</id><summary type="html">&lt;p&gt;For some reasons you will find yourself writing some magical lines of code or having a small/large application that needs to run all the time and shouldn&amp;#8217;t&amp;nbsp;fail.&lt;/p&gt;
&lt;p&gt;To accomplish this, we need something to keep an eye on that magic or application and ensure to keep it up and running all the time, here comes the usefulness of&amp;nbsp;supervisor.&lt;/p&gt;
&lt;p&gt;This story assumes that you are familiar with the command line and Sysadmin&amp;nbsp;basics.&lt;/p&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Supervisor&lt;/strong&gt; is a simple and popular python application for process controlling and monitoring. on the other hand it&amp;#8217;s a program that runs and watch other programs to ensure they are executed all the&amp;nbsp;time.&lt;/p&gt;
&lt;p&gt;On the next lines, we are going to demonstrate how to use it effectively to maintain your applications for a better&amp;nbsp;deployments.&lt;/p&gt;
&lt;h2&gt;Installation and&amp;nbsp;configuration&lt;/h2&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;To install Supervisor on Ubuntu or Debian, we can simply run the following as a super&amp;nbsp;user:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;apt-get install supervisor -y
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Once it has completed, the supervisor daemon should be already running. To make sure it is, run the following&amp;nbsp;command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;service supervisor status
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The command will return &amp;#8216;is running&amp;#8217;, in case it&amp;#8217;s not. You can start it by&amp;nbsp;running.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;service supervisor start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we have done with the installation of the supervisor and ensured of supervisord running. We can write our first configuration file for our&amp;nbsp;application.&lt;/p&gt;
&lt;h3&gt;Configuration&lt;/h3&gt;
&lt;p&gt;I chose celery for this demonstration. Supervisor is a configuration file driven. We are going to write a configuration file for celery to be monitored and controlled by supervisor. Before that we are going to configure our supervisord web&amp;nbsp;interface.&lt;/p&gt;
&lt;p&gt;Configuration files for supervisor are located in /etc/supervisor folder, by adding the following lines to the supervisor configuration file supervisord.conf we are going to be able to access it through our&amp;nbsp;browser.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;inet_http_server&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=*&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9001&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By checking the the url http://127.0.0.1:9001 we can access the web interface of our supervisor doemon and it&amp;#8217;s empty&amp;nbsp;now.&lt;/p&gt;
&lt;p&gt;&lt;img alt="supervisor web ui" src="http://www.yusuf.im/images/supervisor_web_ui.png" /&gt;&lt;/p&gt;
&lt;p&gt;Supervisor comes also with supervisorctl, a client command line that allow us to control the processes. It provides a shell like interface to the features provided by supervisord. From supervisorctl, we can connect to different supervisord processes, get status on the subprocesses controlled by, stop and start subprocesses of, and get lists of running processes of a&amp;nbsp;supervisord.&lt;/p&gt;
&lt;p&gt;As we see on the previous screenshot we don&amp;#8217;t have any monitored process yet, so let&amp;#8217;s create a configuration file for celery&amp;nbsp;application.&lt;/p&gt;
&lt;p&gt;We need to create a new configuration file at /etc/supervisor/conf.d/ folder and we are going to call it celery.conf, the extension .conf is so important as we see on the supervisor configuration file, it includes any file with .conf&amp;nbsp;extension.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;supervisor&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/*.&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we need to tell Supervisord how to run and monitor celery. We are going to put the following lines in our&amp;nbsp;celery.conf&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;celeryd&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nb"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;celery&lt;/span&gt; &lt;span class="n"&gt;worker&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;loglevel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;INFO&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;yusuf&lt;/span&gt;
&lt;span class="n"&gt;numprocs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;stdout_logfile&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;celery&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;worker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;
&lt;span class="n"&gt;stderr_logfile&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;celery&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;worker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;
&lt;span class="n"&gt;autostart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;
&lt;span class="n"&gt;autorestart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;
&lt;span class="n"&gt;startsecs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;stopwaitsecs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;600&lt;/span&gt;
&lt;span class="n"&gt;killasgroup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;
&lt;span class="n"&gt;priority&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;998&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now let&amp;#8217;s check the web interface again, we see that our monitored application appeared on the&amp;nbsp;list.&lt;/p&gt;
&lt;p&gt;&lt;img alt="supervisor running celery" src="supervisor_celeryd.png" /&gt;&lt;/p&gt;
&lt;p&gt;We can use the client command line by&amp;nbsp;running&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; supervisorctrl status
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In case there are no errors on our config file it will return something like that, telling us that our application is running and monitored by&amp;nbsp;supervisor.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;celeryd                          RUNNING    pid 27, uptime 0:05:07
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;##Supervisor and&amp;nbsp;Virtualenv&lt;/p&gt;
&lt;p&gt;On the previous celery configuration, we installed celery globally on our system. For many reasons python developers prefer to use virtualenv for both development and production mode, so we are going to modify our previous configuration, in case celery is installed on a python virtual&amp;nbsp;environment.  &lt;/p&gt;
&lt;p&gt;Our celery.conf will looks like&amp;nbsp;that.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[program:celeryd]&lt;/span&gt;
&lt;span class="na"&gt;environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;PYTHONPATH=&amp;#39;/path/to/your/env&amp;#39;&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/path/to/your/env/bin/celery worker --loglevel=INFO&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/usr/bin/celery worker -B --loglevel=INFO&lt;/span&gt;
&lt;span class="na"&gt;user&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;yusuf&lt;/span&gt;
&lt;span class="na"&gt;numprocs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/var/log/celery/worker.log&lt;/span&gt;
&lt;span class="na"&gt;stderr_logfile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/var/log/celery/worker.err&lt;/span&gt;
&lt;span class="na"&gt;autostart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="na"&gt;autorestart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="na"&gt;startsecs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;10&lt;/span&gt;
&lt;span class="na"&gt;stopwaitsecs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;600&lt;/span&gt;
&lt;span class="na"&gt;killasgroup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="na"&gt;priority&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;998&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;span class="caps"&gt;PYTHONPATH&lt;/span&gt; section is setting up the python path to the virtualenv. So when supervisor goes to execute the command it will be executing it within the&amp;nbsp;virtualenv.&lt;/p&gt;
&lt;h2&gt;Supervisor and&amp;nbsp;Superlance&lt;/h2&gt;
&lt;p&gt;Superlance is a python package of plugin utilities for monitoring and controlling processes that run under supervisor by listening to supervisord&amp;nbsp;events.&lt;/p&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;It can be installed easily by typing the following&amp;nbsp;command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pip install superlance
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Superlance comes with five even&amp;nbsp;listeners:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;httpok
    &amp;gt; This plugin is meant to be used as a supervisor event listener, subscribed to TICK_* events. It tests that a given child process which must in the &lt;span class="caps"&gt;RUNNING&lt;/span&gt; state, is viable via an &lt;span class="caps"&gt;HTTP&lt;/span&gt; &lt;span class="caps"&gt;GET&lt;/span&gt; request to a configured &lt;span class="caps"&gt;URL&lt;/span&gt;. If the request fails or times out, httpok will restart the “hung” child&amp;nbsp;process.&lt;/li&gt;
&lt;li&gt;crashmail
    &amp;gt; This plugin is meant to be used as a supervisor event listener, subscribed to PROCESS_STATE_EXITED events. It email a user when a process enters the &lt;span class="caps"&gt;EXITED&lt;/span&gt; state&amp;nbsp;unexpectedly.&lt;/li&gt;
&lt;li&gt;memmon
    &amp;gt; This plugin is meant to be used as a supervisor event listener, subscribed to TICK_* events. It monitors memory usage for configured child processes, and restarts them when they exceed a configured maximum&amp;nbsp;size.&lt;/li&gt;
&lt;li&gt;crashmailbatch
    &amp;gt; Similar to crashmail, crashmailbatch sends email alerts when processes die unexpectedly. The difference is that all alerts generated within the configured time interval are batched together to avoid sending too many&amp;nbsp;emails.&lt;/li&gt;
&lt;li&gt;fatalmailbatch
    &amp;gt; This plugin sends email alerts when processes fail to start too many times such that supervisord gives up retrying. All of the fatal start events generated within the configured time interval are batched together to avoid sending too many&amp;nbsp;emails.&lt;/li&gt;
&lt;li&gt;crashsms
    &amp;gt; Similar to crashmailbatch except it sends &lt;span class="caps"&gt;SMS&lt;/span&gt; alerts through an email gateway. Messages are formatted to fit in &lt;span class="caps"&gt;SMS&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this story we are going to talk only about crashmail and configure it for our&amp;nbsp;needs.&lt;/p&gt;
&lt;p&gt;We are going to edit supervisord.conf file by adding the following lines to the configuration&amp;nbsp;file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;eventlistener&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;crashmail&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;crashmail&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="nd"&gt;@example.com&lt;/span&gt;
&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;PROCESS_STATE_EXITED&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you want to get notified only for a specific application, for example celeryd in our&amp;nbsp;case:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[eventlistener:crashmail]&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;crashmail -p celeryd -m dev@example.com&lt;/span&gt;
&lt;span class="na"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;PROCESS_STATE_EXITED&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For more information about superlancer i recommend you to check their documentation at&amp;nbsp;http://superlance.readthedocs.org/en/latest/&lt;/p&gt;</summary><category term="supervisor"></category><category term="superlance"></category><category term="celery"></category><category term="virtualenv"></category></entry></feed>